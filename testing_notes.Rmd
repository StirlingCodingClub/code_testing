---
title: "Introduction to testing R code"
author: "John Wilson, Brad Duthie"
date: "1 May 2019"
output: 
    html_document:
        code_folding: show
---

Contents
================================================================================

********************************************************************************

**Note: Please think of this document as a living document, which you are free to improve (like a [wiki](https://en.wikipedia.org/wiki/Wiki)) with minor edits, new sections that others might find useful, or [additional resources](#whatelse) that you find that you think others might also find useful. After reading through this, you will have been introduced to the basic principles of writing tests for the code that you have written.**

********************************************************************************

- [Introduction: Why code testing?](#intro)
- [The testthat R package](#testthat) 
- [Additional resources](#whatelse)

********************************************************************************

<a name="intro">Introduction: Why code testing?</a>
================================================================================



<a name="testthat">The testthat R package</a>
================================================================================

**What is the testthat package?**

The [testthat R package](https://github.com/r-lib/testthat) is a helpful way to get started writing tests for the code that you write. Testing code is often boring and tedious, and it is usually very tempting to bypass this stage of the coding process entirely. Once you have code that works (often obtained only after a lot of hard work), you want to use it, not think about all of the ways that it could eventually fail. The [testthat R package](https://github.com/r-lib/testthat) tries to make testing as easy and interesting as possible, so that you will actually want to do it after you have finished coding something. It does this by minimising the amount of effort that goes into writing code tests and maximising how cool it is to watch all of your tests being passed. For example, here is what testing looks like for a reasonably sized [R package](https://confoobio.github.io/gmse/).

<center><br>
![](images/gmse_test.png)
</center><br>

All of the 143 tests click through one by one to make sure that all of the functions in the package are working as intended. How does testthat determine that the functions are working as intended? Each individual test runs a function with a known input and output. The input is read into the argument's functions, and the output is examined by the test against some criteria, which could be some particular value, object type, or object size. Seeing this in practice below will make it clearer, but the general idea is that after writing the code, you know what the output *should* be for a particular input. As you continue to code more and regularly test, if that output changes or returns an error, then the automated process of testing with testthat will catch the problem and tell you what needs to be fixed.

**How do I get started with testthat?**

The first thing that you need to do is install the [testthat R package](https://github.com/r-lib/testthat). This can be done from CRAN using the code below.

```{r, eval = FALSE, echo = TRUE}
install.packages("testthat")
```

Alternatively, you can donwload [testthat](https://github.com/r-lib/testthat) from GitHub if you have the [devtools](https://github.com/r-lib/devtools) R package installed.

```{r, eval = FALSE, echo = TRUE}
devtools::install_github("r-lib/testthat");
```

Once [testthat](https://github.com/r-lib/testthat) is installed, you can load it into Rstudio just like any other R package.

```{r, eval = TRUE, echo = TRUE}
library(testthat);
```

You are now ready to start writing R scripts to test the functions that you have written. First, however, we need to add some functions. I will use two simple temperature conversion functions written in a previous coding club session on [writing R packages](https://stirlingcodingclub.github.io/SCC_R_package/notebook/Rpackage_notes.html).

**Two simple functions that will be tested**

When you code, it is often a good idea to try to write short functions. There is no hard rule for determining when a function is too long, but whenever possible, it is usually best to avoid writing functions with too many lines to view all at once on your monitor. Small functions that do one job, which can be called by *other* functions as necessary, make coding easier later on because this allows you to compartmentalise specific tasks and better see how everything fits together at once ([here is](https://github.com/bradduthie/RandomMatrixStability/blob/master/R/ga.R) a good example of this in R code; [here is](https://github.com/bradduthie/EcoEdu/blob/master/R/sim_pop_gen.R) a bad example; and [here is](https://github.com/bradduthie/pre_post_cop/blob/master/code/Inbreed.c#L33) a *very* bad example; all of these work, but the first is much nicer to read and test). Small functions are also easier to test because it is clearer what output you are expecting for a particular function input. Many small functions (rather than a few large ones) also allow you to run more tests and better pinpoint the problem when something goes wrong.

Take the a simple [R script](https://github.com/StirlingCodingClub/SCC_R_package/blob/master/R/temp_conversion.R) with two custom R functions. The first function converts a temperature from Fahrenheit to Celsius.

```{r}
F_to_C <- function(F_temp){
    C_temp <- (F_temp - 32) * 5/9;
    return(C_temp);
}
```

The second function converts from Celsius to Fahrenheit.

```{r}
C_to_F <- function(C_temp){
    F_temp <- (C_temp * 9/5) + 32;
    return(F_temp);
}
```

It might not seem like there is much reason for testing these functions. They are both tiny, really only a single line of code doing the work. The maths can be checked by eye, and the function can likewise be checked easily by running a known temperature through each function and looking at the output (which you would naturally do after first writing the functions to double-check that they work). Nevertheless, if these functions were embedded within a much larger R script with other functions to process a large data set and run one or more analyses, an automated test to ensure that each is working as intended is probably worth writing. A test could of course check to make sure that the converted value returned is correct for some arbitrary temperature input, but you also might want to make sure that the output is being returned in a particular format; e.g., as a numeric -- or specifically as a value of type 'double' rather than an integer. For more complex functions, you might want to ensure that the *dimensions* of the output are correct (e.g., a matrix with a specific number of rows and columns, or a list with 3 elements of different types).


We then can write functions to be used with the testthat R package to test each of these. The below tests the `F_to_C` function.

```{r, eval = FALSE}
test_that("Fahrenheit to Celsius", {
  
  temp_C <- F_to_C(50);
  
  # Test that the result is numeric
  expect_that( is.numeric(temp_C), equals(TRUE) );
  
  # Test that the result is the correct value
  expect_that( temp_C, equals(10) );
})
```

The below tests the `C_to_F` function.

```{r, eval = FALSE}
test_that("Celsius to Fahrenheit", {
  
  temp_F <- C_to_F(10);
  
  # Test that the result is numeric
  expect_that( is.numeric(temp_F), equals(TRUE) );
  
  # Test that the result is the correct value
  expect_that( temp_F, equals(50) );
})
```

How to use this is fairly straightforward.



<a name="whatelse">Additional resources</a>
================================================================================


- [Example of unit testing R code with testthat](https://www.johndcook.com/blog/2013/06/12/example-of-unit-testing-r-code-with-testthat/) (John D. Cook)
- [Testing R packages](http://r-pkgs.had.co.nz/tests.html) (Hadley Wickam)
